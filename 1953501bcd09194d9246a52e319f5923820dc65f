{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9e9f75ad_484b0f8c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-09-10T01:12:52Z",
      "side": 1,
      "message": "This is the Rust version of the C++ implementation in ParcelableHolder.h.\nWorks fine with the existing NDK-Rust interface, but it\u0027s slightly more complex than an implementation based on AParcelableHolder.\nThoughts?",
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "834ffe13_e039f85d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-09-10T01:14:09Z",
      "side": 1,
      "message": "Basically, what I\u0027m asking is: keep this version or rewrite based on the simpler AParcelableHolder?",
      "parentUuid": "9e9f75ad_484b0f8c",
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b011dde5_8bd9255f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-09-10T18:06:24Z",
      "side": 1,
      "message": "Does this work correctly with the stability (VINTF/non-VINTF) stuff?",
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b1c8ba2_805ed592",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-09-10T20:37:03Z",
      "side": 1,
      "message": "The ParcelableHolder object constructor takes a Stability value which is either Local or Vintf, and set_parcelable checks that stability exactly like the C++ code does. Is there more to it than that?",
      "parentUuid": "b011dde5_8bd9255f",
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7858ac9_a6603547",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1386891
      },
      "writtenOn": "2021-09-13T15:43:36Z",
      "side": 1,
      "message": "I don\u0027t mind either way. (even though this version is more efficient and complex)",
      "parentUuid": "834ffe13_e039f85d",
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73d189e0_92fcd062",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2021-09-10T02:12:23Z",
      "side": 1,
      "message": "We don\u0027t want to reset \"stability\". Stability is set when creating an object and persist along with it. I\u0027m curious if we can model this with type system.",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 64,
        "endChar": 62
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f44f412e_44135f91",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-09-10T22:58:13Z",
      "side": 1,
      "message": "We could make ParcelableHolder generic over the stability, i.e., ParcelableHolder\u003cS\u003e and concrete types ParcelableHolder\u003cLocal\u003e and ParcelableHolder\u003cVintf\u003e, but that\u0027s something the C++ code could have done too. Should we keep the Rust API exactly like the C++ one?",
      "parentUuid": "73d189e0_92fcd062",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 64,
        "endChar": 62
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dd15a254_7a923b29",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2021-09-13T11:22:29Z",
      "side": 1,
      "message": "\u003e ParcelableHolder\u003cS\u003e\n\nYes, that\u0027s what I was thinking. Unless we want to the same thing to C++ parcelableholder, let\u0027s keep this way. I\u0027m fine with this.",
      "parentUuid": "f44f412e_44135f91",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 64,
        "endChar": 62
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dd337a9f_55c6784e",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-09-15T01:51:07Z",
      "side": 1,
      "message": "I decided to give this a try and discovered ParcelableHolder\u003cS\u003e wouldn\u0027t work because the first thing read_from_parcel() does is read the stability, so it would have to immediately replace `self` with a ParcelableHolder\u003cS\u003e with another stability which isn\u0027t possible (in Rust or C++, I think). For example, you\u0027d need to assign a ParcelableHolder\u003cVintf\u003e to `self` which wouldn\u0027t work if `self` were already a ParcelableHolder\u003cLocal\u003e.\n\nThis wouldn\u0027t work even if we modified read_from_parcel() to return a new object, i.e., Result\u003cSelf\u003e.",
      "parentUuid": "dd15a254_7a923b29",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 64,
        "endChar": 62
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "55a0fb77_36cef299",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2021-09-15T01:58:21Z",
      "side": 1,
      "message": "Thank you for the experiment.",
      "parentUuid": "dd337a9f_55c6784e",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 64,
        "endChar": 62
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0fa6a11c_74e324e8",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 70,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-09-14T00:23:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d0f5d994_7ef0ebcf",
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "156359b2_e44ce2d8",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 186,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2021-09-10T02:12:23Z",
      "side": 1,
      "message": "In C++(and other languages), we add a comment like: /*include_size\u003d*/.\n\nbtw, why we don\u0027t include size? C++ backend writes the size of (name + parcelable)",
      "range": {
        "startLine": 186,
        "startChar": 35,
        "endLine": 186,
        "endChar": 40
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b80436c3_ea0b4a19",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 186,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-09-10T22:58:13Z",
      "side": 1,
      "message": "\u003e In C++(and other languages), we add a comment like: /*include_size\u003d*/.\nI haven\u0027t seen a lot of that in Rust, but it can\u0027t hurt either. I\u0027ll add it.\n\n\u003e btw, why we don\u0027t include size? C++ backend writes the size of (name + parcelable)\nC++ ParcelableHolder doesn\u0027t include the size either, not sure why.\nJeongik would know?",
      "parentUuid": "156359b2_e44ce2d8",
      "range": {
        "startLine": 186,
        "startChar": 35,
        "endLine": 186,
        "endChar": 40
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5366476_deccd52d",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 186,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2021-09-13T11:22:29Z",
      "side": 1,
      "message": "Oh, I see. ParcelableHolder write(s)ToParcel in a \"length prefixed way\", which is different from structured parcelables. Since ParcelableHolder is a hand-written parcelable class, it doesn\u0027t have to follow the structured parcelable.\n\nbtw, since this is specific to ParcelableHolder, I don\u0027t think we need to extend sized_write API to have an additional parameter(include_length). IMO it makes code a bit hard to read.",
      "parentUuid": "b80436c3_ea0b4a19",
      "range": {
        "startLine": 186,
        "startChar": 35,
        "endLine": 186,
        "endChar": 40
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "14f88bd6_6ec302b2",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 186,
      "author": {
        "id": 1386891
      },
      "writtenOn": "2021-09-13T15:43:36Z",
      "side": 1,
      "message": "The reason why ParcelableHolder writes down data size which doesn\u0027t \u0027include length\u0027 is for simple appendFrom in readFromParcel.\n\nBTW, the param name is a little bit confusing for me :) (I understand it now but, sized_write without length..?)",
      "parentUuid": "d5366476_deccd52d",
      "range": {
        "startLine": 186,
        "startChar": 35,
        "endLine": 186,
        "endChar": 40
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "59f0bade_f3323b18",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 186,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-09-14T01:24:20Z",
      "side": 1,
      "message": "I got rid of the include_length argument, and replaced sized_write call here with the actual code.",
      "parentUuid": "14f88bd6_6ec302b2",
      "range": {
        "startLine": 186,
        "startChar": 35,
        "endLine": 186,
        "endChar": 40
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ea004d8_73dd138b",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 188,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2021-09-10T02:12:23Z",
      "side": 1,
      "message": "if we don\u0027t need to put size, why not just use parcel?\n\n  parcel.write(..)\n  parcel.write_..",
      "range": {
        "startLine": 187,
        "startChar": 0,
        "endLine": 188,
        "endChar": 61
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06a28aa3_6881fcb9",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 188,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-09-10T22:58:13Z",
      "side": 1,
      "message": "include_size/include_length is a bit ambiguous here. What it means is that it does prepend the size, but the size of the size field itself is counted too (or not if include_length\u003dfalse). For example, writing an 8 byte payload writes a size of 12(4+8) with include_length\u003dtrue, but a size of 8 with include_length\u003dfalse.\n\nI\u0027m happy to bikeshed the name of \"include_length\", if anyone can think of a better alternative.",
      "parentUuid": "0ea004d8_73dd138b",
      "range": {
        "startLine": 187,
        "startChar": 0,
        "endLine": 188,
        "endChar": 61
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "37194f9f_4237a309",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 188,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-09-14T01:24:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "06a28aa3_6881fcb9",
      "range": {
        "startLine": 187,
        "startChar": 0,
        "endLine": 188,
        "endChar": 61
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09ddbb71_1bfc43eb",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 202,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-09-08T23:46:04Z",
      "side": 1,
      "message": "The rest of libbinder generally only seems to check against NULL_PARCELABLE_FLAG (0), so it accepts all non-zero values, but C++ ParcelableHolder rejects everything except NON_NULL_PARCELABLE_FLAG (1).",
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0fc8f493_97b0b512",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 6
      },
      "lineNbr": 236,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2021-09-10T02:21:04Z",
      "side": 1,
      "message": "nit: can we have an API like Parcel#read_parcel(size) which returns a new Parcel with that amount of data from self. (It moves position as well.)\n\nBut, yeah, it would be overkill.",
      "range": {
        "startLine": 227,
        "startChar": 0,
        "endLine": 236,
        "endChar": 9
      },
      "revId": "1953501bcd09194d9246a52e319f5923820dc65f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}